# backend/services/crud_usuario.py
from typing import List, Dict, Optional
from database.connection import get_connection
from database.models import Usuario, Bairro, Ocorrencia
import json, os, oracledb

DDL_USUARIO = """
CREATE TABLE usuario (
    id            NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nome          VARCHAR2(100) NOT NULL,
    papel         VARCHAR2(50)  NOT NULL,
    email         VARCHAR2(100) NOT NULL UNIQUE
)
"""

DDL_BAIRRO = """
CREATE TABLE bairro (
    id               NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nome             VARCHAR2(100) NOT NULL,
    area_risco_prop  FLOAT,
    pop_densidade    FLOAT
)
"""

DDL_OCORRENCIA = """
CREATE TABLE ocorrencia (
    id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    titulo       VARCHAR2(150) NOT NULL,
    descricao    CLOB NOT NULL,
    categoria    VARCHAR2(50) NOT NULL,
    data         DATE NOT NULL,
    status       VARCHAR2(50) NOT NULL,
    localizacao  VARCHAR2(150),
    usuario_id   NUMBER NOT NULL,
    bairro_id    NUMBER NOT NULL,
    CONSTRAINT fk_usuario
        FOREIGN KEY (usuario_id)
        REFERENCES usuario(id),
    CONSTRAINT fk_bairro
        FOREIGN KEY (bairro_id)
        REFERENCES bairro(id)
)
"""

def criar_tabelas():
    """
    Executa os DDLs para criar as 3 tabelas: usuario, bairro e ocorrencia.
    Use apenas uma vez, ou se as tabelas não existirem.
    """
    conn = get_connection()
    cursor = conn.cursor()
    for ddl in (DDL_USUARIO, DDL_BAIRRO, DDL_OCORRENCIA):
        try:
            cursor.execute(ddl)
        except Exception:
            # Ignora caso já exista
            pass
    conn.commit()
    cursor.close()

def criar_usuario(nome: str, papel: str, email: str) -> int:
    """
    Insere um novo usuário e retorna o ID gerado.
    """
    conn = get_connection()
    cursor = conn.cursor()
    sql = """
    INSERT INTO usuario (nome, papel, email)
    VALUES (:nome, :papel, :email)
    RETURNING id INTO :id_out
    """
    id_out = cursor.var(int)
    cursor.execute(sql, {"nome": nome, "papel": papel, "email": email, "id_out": id_out})
    conn.commit()
    novo_id = id_out.getvalue()[0]
    cursor.close()
    return novo_id

def listar_usuarios() -> List[Dict]:
    """
    Retorna lista de todos os usuários no formato de dicionário.
    """
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT id, nome, papel, email FROM usuario ORDER BY id")
    cols = [col[0].lower() for col in cursor.description]
    resultados = [dict(zip(cols, row)) for row in cursor.fetchall()]
    cursor.close()
    return resultados

def criar_bairro(nome: str, area_risco_prop: float, pop_densidade: float) -> int:
    """
    Insere um novo bairro e retorna o ID gerado.
    """
    conn = get_connection()
    cursor = conn.cursor()
    sql = """
    INSERT INTO bairro (nome, area_risco_prop, pop_densidade)
    VALUES (:nome, :area_risco_prop, :pop_densidade)
    RETURNING id INTO :id_out
    """
    id_out = cursor.var(int)
    cursor.execute(sql, {
        "nome": nome,
        "area_risco_prop": area_risco_prop,
        "pop_densidade": pop_densidade,
        "id_out": id_out
    })
    conn.commit()
    novo_id = id_out.getvalue()[0]
    cursor.close()
    return novo_id

def listar_bairros() -> List[Dict]:
    """
    Retorna lista de todos os bairros com suas features.
    """
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT id, nome, area_risco_prop, pop_densidade FROM bairro ORDER BY id")
    cols = [col[0].lower() for col in cursor.description]
    resultados = [dict(zip(cols, row)) for row in cursor.fetchall()]
    cursor.close()
    return resultados

def criar_ocorrencia(titulo: str, descricao: str, categoria: str,
                     data: str, status: str, localizacao: str,
                     usuario_id: int, bairro_id: int) -> int:
    """
    Insere uma nova ocorrência e retorna o ID gerado.
    O campo 'data' deve chegar como string 'YYYY-MM-DD'; converta para DATE no SQL.
    """
    conn = get_connection()
    cursor = conn.cursor()
    sql = """
    INSERT INTO ocorrencia
    (titulo, descricao, categoria, data, status, localizacao, usuario_id, bairro_id)
    VALUES (:titulo, :descricao, :categoria, TO_DATE(:data, 'YYYY-MM-DD'), :status, :localizacao, :usuario_id, :bairro_id)
    RETURNING id INTO :id_out
    """
    id_out = cursor.var(int)
    cursor.execute(sql, {
        "titulo": titulo,
        "descricao": descricao,
        "categoria": categoria,
        "data": data,
        "status": status,
        "localizacao": localizacao,
        "usuario_id": usuario_id,
        "bairro_id": bairro_id,
        "id_out": id_out
    })
    conn.commit()
    novo_id = id_out.getvalue()[0]
    cursor.close()
    return novo_id

def listar_ocorrencias() -> List[Dict]:
    """
    Retorna lista de todas as ocorrências, com JOIN em usuario e bairro para exibir nomes.
    """
    conn = get_connection()
    cursor = conn.cursor()
    sql = """
    SELECT 
      o.id,
      o.titulo,
      o.descricao,
      o.categoria,
      TO_CHAR(o.data, 'YYYY-MM-DD') as data,
      o.status,
      o.localizacao,
      u.nome as usuario,
      b.nome as bairro
    FROM ocorrencia o
    JOIN usuario u ON o.usuario_id = u.id
    JOIN bairro b  ON o.bairro_id   = b.id
    ORDER BY o.id
    """
    cursor.execute(sql)
    cols = [col[0].lower() for col in cursor.description]
    resultados: List[Dict[str, any]] = []
    for row in cursor:
        row_list = list(row)
        for idx, val in enumerate(row_list):
            if isinstance(val, oracledb.LOB):
                row_list[idx] = val.read()
    resultados.append(dict(zip(cols, row_list)))
    cursor.close()
    conn.close()
    return resultados

def buscar_ocorrencias_por_categoria(categoria: str) -> List[Dict]:
    """
    Busca ocorrências por categoria exata.
    """
    conn = get_connection()
    cursor = conn.cursor()
    sql = """
    SELECT
      o.id,
      o.titulo,
      o.descricao,
      o.categoria,
      TO_CHAR(o.data, 'YYYY-MM-DD') as data,
      o.status,
      o.localizacao,
      u.nome as usuario,
      b.nome as bairro
    FROM ocorrencia o
    JOIN usuario u ON o.usuario_id = u.id
    JOIN bairro b  ON o.bairro_id   = b.id
    WHERE o.categoria = :categoria
    ORDER BY o.id
    """
    try:
        cursor.execute(sql, {"categoria": categoria})
    except Exception:
        # Se der qualquer erro de SQL/execution, fechar e retornar vazio
        cursor.close()
        conn.close()
        return []

    # Verifica se há colunas 
    if cursor.description is None:
        cursor.close()
        conn.close()
        return []

    cols = [col[0].lower() for col in cursor.description]
    resultados: List[Dict[str, any]] = []

    for row in cursor:
        row_list: List[any] = []
        for val in row:
            if isinstance(val, oracledb.LOB):
                try:
                    row_list.append(val.read())
                except Exception:
                    row_list.append("")  # Se por algum motivo não der pra ler, devolve string vazia
            else:
                row_list.append(val)
        resultados.append(dict(zip(cols, row_list)))

    cursor.close()
    conn.close()
    return resultados

def atualizar_ocorrencia(id: int, novos_dados: Dict[str, str]) -> bool:
    """
    Atualiza campos de uma ocorrência existente. 
    'novos_dados' é um dicionário {coluna: valor_str}.
    Retorna True se atualizou pelo menos uma linha, False caso não encontre o ID.
    """
    conn = get_connection()
    cursor = conn.cursor()

    # Monta SET dinamicamente, cuidando de data
    set_clauses = []
    params = {}
    for key, value in novos_dados.items():
        if key == "data":
            set_clauses.append("data = TO_DATE(:data, 'YYYY-MM-DD')")
            params["data"] = value
        else:
            set_clauses.append(f"{key} = :{key}")
            params[key] = value
    params["id"] = id

    sql = f"""
    UPDATE ocorrencia
    SET {', '.join(set_clauses)}
    WHERE id = :id
    """
    cursor.execute(sql, params)
    count = cursor.rowcount
    conn.commit()
    cursor.close()
    return count > 0

def deletar_ocorrencia(id: int) -> bool:
    """
    Deleta ocorrência pelo ID. Retorna True se excluiu, False se não encontrou.
    """
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("DELETE FROM ocorrencia WHERE id = :id", {"id": id})
    count = cursor.rowcount
    conn.commit()
    cursor.close()
    return count > 0

def exportar_ocorrencias_json(nome_arquivo: str = "ocorrencias_export.json") -> None:
    """
    Exporta todas as ocorrências (com JOIN em usuario e bairro) para JSON em backend/export/.
    """
    ocorrencias = listar_ocorrencias()
    os.makedirs("export", exist_ok=True)
    caminho = os.path.join("export", nome_arquivo)
    with open(caminho, "w", encoding="utf-8") as f:
        json.dump(ocorrencias, f, indent=4, ensure_ascii=False)